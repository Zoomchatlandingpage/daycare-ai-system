
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `LearningEvent` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model LearningEvent
 * 
 */
export type LearningEventModel = runtime.Types.Result.DefaultSelection<Prisma.$LearningEventPayload>

export type AggregateLearningEvent = {
  _count: LearningEventCountAggregateOutputType | null
  _min: LearningEventMinAggregateOutputType | null
  _max: LearningEventMaxAggregateOutputType | null
}

export type LearningEventMinAggregateOutputType = {
  id: string | null
  recorded_by_id: string | null
  activity: string | null
  description: string | null
  classroom: string | null
  is_group: boolean | null
  logged_at: Date | null
}

export type LearningEventMaxAggregateOutputType = {
  id: string | null
  recorded_by_id: string | null
  activity: string | null
  description: string | null
  classroom: string | null
  is_group: boolean | null
  logged_at: Date | null
}

export type LearningEventCountAggregateOutputType = {
  id: number
  recorded_by_id: number
  activity: number
  description: number
  skills: number
  classroom: number
  is_group: number
  logged_at: number
  _all: number
}


export type LearningEventMinAggregateInputType = {
  id?: true
  recorded_by_id?: true
  activity?: true
  description?: true
  classroom?: true
  is_group?: true
  logged_at?: true
}

export type LearningEventMaxAggregateInputType = {
  id?: true
  recorded_by_id?: true
  activity?: true
  description?: true
  classroom?: true
  is_group?: true
  logged_at?: true
}

export type LearningEventCountAggregateInputType = {
  id?: true
  recorded_by_id?: true
  activity?: true
  description?: true
  skills?: true
  classroom?: true
  is_group?: true
  logged_at?: true
  _all?: true
}

export type LearningEventAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which LearningEvent to aggregate.
   */
  where?: Prisma.LearningEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of LearningEvents to fetch.
   */
  orderBy?: Prisma.LearningEventOrderByWithRelationInput | Prisma.LearningEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.LearningEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` LearningEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` LearningEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned LearningEvents
  **/
  _count?: true | LearningEventCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: LearningEventMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: LearningEventMaxAggregateInputType
}

export type GetLearningEventAggregateType<T extends LearningEventAggregateArgs> = {
      [P in keyof T & keyof AggregateLearningEvent]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateLearningEvent[P]>
    : Prisma.GetScalarType<T[P], AggregateLearningEvent[P]>
}




export type LearningEventGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.LearningEventWhereInput
  orderBy?: Prisma.LearningEventOrderByWithAggregationInput | Prisma.LearningEventOrderByWithAggregationInput[]
  by: Prisma.LearningEventScalarFieldEnum[] | Prisma.LearningEventScalarFieldEnum
  having?: Prisma.LearningEventScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: LearningEventCountAggregateInputType | true
  _min?: LearningEventMinAggregateInputType
  _max?: LearningEventMaxAggregateInputType
}

export type LearningEventGroupByOutputType = {
  id: string
  recorded_by_id: string
  activity: string
  description: string
  skills: string[]
  classroom: string | null
  is_group: boolean
  logged_at: Date
  _count: LearningEventCountAggregateOutputType | null
  _min: LearningEventMinAggregateOutputType | null
  _max: LearningEventMaxAggregateOutputType | null
}

type GetLearningEventGroupByPayload<T extends LearningEventGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<LearningEventGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof LearningEventGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], LearningEventGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], LearningEventGroupByOutputType[P]>
      }
    >
  >



export type LearningEventWhereInput = {
  AND?: Prisma.LearningEventWhereInput | Prisma.LearningEventWhereInput[]
  OR?: Prisma.LearningEventWhereInput[]
  NOT?: Prisma.LearningEventWhereInput | Prisma.LearningEventWhereInput[]
  id?: Prisma.StringFilter<"LearningEvent"> | string
  recorded_by_id?: Prisma.StringFilter<"LearningEvent"> | string
  activity?: Prisma.StringFilter<"LearningEvent"> | string
  description?: Prisma.StringFilter<"LearningEvent"> | string
  skills?: Prisma.StringNullableListFilter<"LearningEvent">
  classroom?: Prisma.StringNullableFilter<"LearningEvent"> | string | null
  is_group?: Prisma.BoolFilter<"LearningEvent"> | boolean
  logged_at?: Prisma.DateTimeFilter<"LearningEvent"> | Date | string
  recorded_by?: Prisma.XOR<Prisma.TeacherScalarRelationFilter, Prisma.TeacherWhereInput>
  participants?: Prisma.LearningParticipantListRelationFilter
}

export type LearningEventOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  recorded_by_id?: Prisma.SortOrder
  activity?: Prisma.SortOrder
  description?: Prisma.SortOrder
  skills?: Prisma.SortOrder
  classroom?: Prisma.SortOrderInput | Prisma.SortOrder
  is_group?: Prisma.SortOrder
  logged_at?: Prisma.SortOrder
  recorded_by?: Prisma.TeacherOrderByWithRelationInput
  participants?: Prisma.LearningParticipantOrderByRelationAggregateInput
}

export type LearningEventWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.LearningEventWhereInput | Prisma.LearningEventWhereInput[]
  OR?: Prisma.LearningEventWhereInput[]
  NOT?: Prisma.LearningEventWhereInput | Prisma.LearningEventWhereInput[]
  recorded_by_id?: Prisma.StringFilter<"LearningEvent"> | string
  activity?: Prisma.StringFilter<"LearningEvent"> | string
  description?: Prisma.StringFilter<"LearningEvent"> | string
  skills?: Prisma.StringNullableListFilter<"LearningEvent">
  classroom?: Prisma.StringNullableFilter<"LearningEvent"> | string | null
  is_group?: Prisma.BoolFilter<"LearningEvent"> | boolean
  logged_at?: Prisma.DateTimeFilter<"LearningEvent"> | Date | string
  recorded_by?: Prisma.XOR<Prisma.TeacherScalarRelationFilter, Prisma.TeacherWhereInput>
  participants?: Prisma.LearningParticipantListRelationFilter
}, "id">

export type LearningEventOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  recorded_by_id?: Prisma.SortOrder
  activity?: Prisma.SortOrder
  description?: Prisma.SortOrder
  skills?: Prisma.SortOrder
  classroom?: Prisma.SortOrderInput | Prisma.SortOrder
  is_group?: Prisma.SortOrder
  logged_at?: Prisma.SortOrder
  _count?: Prisma.LearningEventCountOrderByAggregateInput
  _max?: Prisma.LearningEventMaxOrderByAggregateInput
  _min?: Prisma.LearningEventMinOrderByAggregateInput
}

export type LearningEventScalarWhereWithAggregatesInput = {
  AND?: Prisma.LearningEventScalarWhereWithAggregatesInput | Prisma.LearningEventScalarWhereWithAggregatesInput[]
  OR?: Prisma.LearningEventScalarWhereWithAggregatesInput[]
  NOT?: Prisma.LearningEventScalarWhereWithAggregatesInput | Prisma.LearningEventScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"LearningEvent"> | string
  recorded_by_id?: Prisma.StringWithAggregatesFilter<"LearningEvent"> | string
  activity?: Prisma.StringWithAggregatesFilter<"LearningEvent"> | string
  description?: Prisma.StringWithAggregatesFilter<"LearningEvent"> | string
  skills?: Prisma.StringNullableListFilter<"LearningEvent">
  classroom?: Prisma.StringNullableWithAggregatesFilter<"LearningEvent"> | string | null
  is_group?: Prisma.BoolWithAggregatesFilter<"LearningEvent"> | boolean
  logged_at?: Prisma.DateTimeWithAggregatesFilter<"LearningEvent"> | Date | string
}

export type LearningEventCreateInput = {
  id?: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
  recorded_by: Prisma.TeacherCreateNestedOneWithoutLearning_eventsInput
  participants?: Prisma.LearningParticipantCreateNestedManyWithoutLearning_eventInput
}

export type LearningEventUncheckedCreateInput = {
  id?: string
  recorded_by_id: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
  participants?: Prisma.LearningParticipantUncheckedCreateNestedManyWithoutLearning_eventInput
}

export type LearningEventUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  recorded_by?: Prisma.TeacherUpdateOneRequiredWithoutLearning_eventsNestedInput
  participants?: Prisma.LearningParticipantUpdateManyWithoutLearning_eventNestedInput
}

export type LearningEventUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  recorded_by_id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  participants?: Prisma.LearningParticipantUncheckedUpdateManyWithoutLearning_eventNestedInput
}

export type LearningEventCreateManyInput = {
  id?: string
  recorded_by_id: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
}

export type LearningEventUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type LearningEventUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  recorded_by_id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type LearningEventListRelationFilter = {
  every?: Prisma.LearningEventWhereInput
  some?: Prisma.LearningEventWhereInput
  none?: Prisma.LearningEventWhereInput
}

export type LearningEventOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type StringNullableListFilter<$PrismaModel = never> = {
  equals?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  has?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  hasEvery?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  hasSome?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  isEmpty?: boolean
}

export type LearningEventCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  recorded_by_id?: Prisma.SortOrder
  activity?: Prisma.SortOrder
  description?: Prisma.SortOrder
  skills?: Prisma.SortOrder
  classroom?: Prisma.SortOrder
  is_group?: Prisma.SortOrder
  logged_at?: Prisma.SortOrder
}

export type LearningEventMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  recorded_by_id?: Prisma.SortOrder
  activity?: Prisma.SortOrder
  description?: Prisma.SortOrder
  classroom?: Prisma.SortOrder
  is_group?: Prisma.SortOrder
  logged_at?: Prisma.SortOrder
}

export type LearningEventMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  recorded_by_id?: Prisma.SortOrder
  activity?: Prisma.SortOrder
  description?: Prisma.SortOrder
  classroom?: Prisma.SortOrder
  is_group?: Prisma.SortOrder
  logged_at?: Prisma.SortOrder
}

export type LearningEventScalarRelationFilter = {
  is?: Prisma.LearningEventWhereInput
  isNot?: Prisma.LearningEventWhereInput
}

export type LearningEventCreateNestedManyWithoutRecorded_byInput = {
  create?: Prisma.XOR<Prisma.LearningEventCreateWithoutRecorded_byInput, Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput> | Prisma.LearningEventCreateWithoutRecorded_byInput[] | Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput[]
  connectOrCreate?: Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput | Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput[]
  createMany?: Prisma.LearningEventCreateManyRecorded_byInputEnvelope
  connect?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
}

export type LearningEventUncheckedCreateNestedManyWithoutRecorded_byInput = {
  create?: Prisma.XOR<Prisma.LearningEventCreateWithoutRecorded_byInput, Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput> | Prisma.LearningEventCreateWithoutRecorded_byInput[] | Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput[]
  connectOrCreate?: Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput | Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput[]
  createMany?: Prisma.LearningEventCreateManyRecorded_byInputEnvelope
  connect?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
}

export type LearningEventUpdateManyWithoutRecorded_byNestedInput = {
  create?: Prisma.XOR<Prisma.LearningEventCreateWithoutRecorded_byInput, Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput> | Prisma.LearningEventCreateWithoutRecorded_byInput[] | Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput[]
  connectOrCreate?: Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput | Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput[]
  upsert?: Prisma.LearningEventUpsertWithWhereUniqueWithoutRecorded_byInput | Prisma.LearningEventUpsertWithWhereUniqueWithoutRecorded_byInput[]
  createMany?: Prisma.LearningEventCreateManyRecorded_byInputEnvelope
  set?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  disconnect?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  delete?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  connect?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  update?: Prisma.LearningEventUpdateWithWhereUniqueWithoutRecorded_byInput | Prisma.LearningEventUpdateWithWhereUniqueWithoutRecorded_byInput[]
  updateMany?: Prisma.LearningEventUpdateManyWithWhereWithoutRecorded_byInput | Prisma.LearningEventUpdateManyWithWhereWithoutRecorded_byInput[]
  deleteMany?: Prisma.LearningEventScalarWhereInput | Prisma.LearningEventScalarWhereInput[]
}

export type LearningEventUncheckedUpdateManyWithoutRecorded_byNestedInput = {
  create?: Prisma.XOR<Prisma.LearningEventCreateWithoutRecorded_byInput, Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput> | Prisma.LearningEventCreateWithoutRecorded_byInput[] | Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput[]
  connectOrCreate?: Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput | Prisma.LearningEventCreateOrConnectWithoutRecorded_byInput[]
  upsert?: Prisma.LearningEventUpsertWithWhereUniqueWithoutRecorded_byInput | Prisma.LearningEventUpsertWithWhereUniqueWithoutRecorded_byInput[]
  createMany?: Prisma.LearningEventCreateManyRecorded_byInputEnvelope
  set?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  disconnect?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  delete?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  connect?: Prisma.LearningEventWhereUniqueInput | Prisma.LearningEventWhereUniqueInput[]
  update?: Prisma.LearningEventUpdateWithWhereUniqueWithoutRecorded_byInput | Prisma.LearningEventUpdateWithWhereUniqueWithoutRecorded_byInput[]
  updateMany?: Prisma.LearningEventUpdateManyWithWhereWithoutRecorded_byInput | Prisma.LearningEventUpdateManyWithWhereWithoutRecorded_byInput[]
  deleteMany?: Prisma.LearningEventScalarWhereInput | Prisma.LearningEventScalarWhereInput[]
}

export type LearningEventCreateskillsInput = {
  set: string[]
}

export type LearningEventUpdateskillsInput = {
  set?: string[]
  push?: string | string[]
}

export type LearningEventCreateNestedOneWithoutParticipantsInput = {
  create?: Prisma.XOR<Prisma.LearningEventCreateWithoutParticipantsInput, Prisma.LearningEventUncheckedCreateWithoutParticipantsInput>
  connectOrCreate?: Prisma.LearningEventCreateOrConnectWithoutParticipantsInput
  connect?: Prisma.LearningEventWhereUniqueInput
}

export type LearningEventUpdateOneRequiredWithoutParticipantsNestedInput = {
  create?: Prisma.XOR<Prisma.LearningEventCreateWithoutParticipantsInput, Prisma.LearningEventUncheckedCreateWithoutParticipantsInput>
  connectOrCreate?: Prisma.LearningEventCreateOrConnectWithoutParticipantsInput
  upsert?: Prisma.LearningEventUpsertWithoutParticipantsInput
  connect?: Prisma.LearningEventWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.LearningEventUpdateToOneWithWhereWithoutParticipantsInput, Prisma.LearningEventUpdateWithoutParticipantsInput>, Prisma.LearningEventUncheckedUpdateWithoutParticipantsInput>
}

export type LearningEventCreateWithoutRecorded_byInput = {
  id?: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
  participants?: Prisma.LearningParticipantCreateNestedManyWithoutLearning_eventInput
}

export type LearningEventUncheckedCreateWithoutRecorded_byInput = {
  id?: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
  participants?: Prisma.LearningParticipantUncheckedCreateNestedManyWithoutLearning_eventInput
}

export type LearningEventCreateOrConnectWithoutRecorded_byInput = {
  where: Prisma.LearningEventWhereUniqueInput
  create: Prisma.XOR<Prisma.LearningEventCreateWithoutRecorded_byInput, Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput>
}

export type LearningEventCreateManyRecorded_byInputEnvelope = {
  data: Prisma.LearningEventCreateManyRecorded_byInput | Prisma.LearningEventCreateManyRecorded_byInput[]
  skipDuplicates?: boolean
}

export type LearningEventUpsertWithWhereUniqueWithoutRecorded_byInput = {
  where: Prisma.LearningEventWhereUniqueInput
  update: Prisma.XOR<Prisma.LearningEventUpdateWithoutRecorded_byInput, Prisma.LearningEventUncheckedUpdateWithoutRecorded_byInput>
  create: Prisma.XOR<Prisma.LearningEventCreateWithoutRecorded_byInput, Prisma.LearningEventUncheckedCreateWithoutRecorded_byInput>
}

export type LearningEventUpdateWithWhereUniqueWithoutRecorded_byInput = {
  where: Prisma.LearningEventWhereUniqueInput
  data: Prisma.XOR<Prisma.LearningEventUpdateWithoutRecorded_byInput, Prisma.LearningEventUncheckedUpdateWithoutRecorded_byInput>
}

export type LearningEventUpdateManyWithWhereWithoutRecorded_byInput = {
  where: Prisma.LearningEventScalarWhereInput
  data: Prisma.XOR<Prisma.LearningEventUpdateManyMutationInput, Prisma.LearningEventUncheckedUpdateManyWithoutRecorded_byInput>
}

export type LearningEventScalarWhereInput = {
  AND?: Prisma.LearningEventScalarWhereInput | Prisma.LearningEventScalarWhereInput[]
  OR?: Prisma.LearningEventScalarWhereInput[]
  NOT?: Prisma.LearningEventScalarWhereInput | Prisma.LearningEventScalarWhereInput[]
  id?: Prisma.StringFilter<"LearningEvent"> | string
  recorded_by_id?: Prisma.StringFilter<"LearningEvent"> | string
  activity?: Prisma.StringFilter<"LearningEvent"> | string
  description?: Prisma.StringFilter<"LearningEvent"> | string
  skills?: Prisma.StringNullableListFilter<"LearningEvent">
  classroom?: Prisma.StringNullableFilter<"LearningEvent"> | string | null
  is_group?: Prisma.BoolFilter<"LearningEvent"> | boolean
  logged_at?: Prisma.DateTimeFilter<"LearningEvent"> | Date | string
}

export type LearningEventCreateWithoutParticipantsInput = {
  id?: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
  recorded_by: Prisma.TeacherCreateNestedOneWithoutLearning_eventsInput
}

export type LearningEventUncheckedCreateWithoutParticipantsInput = {
  id?: string
  recorded_by_id: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
}

export type LearningEventCreateOrConnectWithoutParticipantsInput = {
  where: Prisma.LearningEventWhereUniqueInput
  create: Prisma.XOR<Prisma.LearningEventCreateWithoutParticipantsInput, Prisma.LearningEventUncheckedCreateWithoutParticipantsInput>
}

export type LearningEventUpsertWithoutParticipantsInput = {
  update: Prisma.XOR<Prisma.LearningEventUpdateWithoutParticipantsInput, Prisma.LearningEventUncheckedUpdateWithoutParticipantsInput>
  create: Prisma.XOR<Prisma.LearningEventCreateWithoutParticipantsInput, Prisma.LearningEventUncheckedCreateWithoutParticipantsInput>
  where?: Prisma.LearningEventWhereInput
}

export type LearningEventUpdateToOneWithWhereWithoutParticipantsInput = {
  where?: Prisma.LearningEventWhereInput
  data: Prisma.XOR<Prisma.LearningEventUpdateWithoutParticipantsInput, Prisma.LearningEventUncheckedUpdateWithoutParticipantsInput>
}

export type LearningEventUpdateWithoutParticipantsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  recorded_by?: Prisma.TeacherUpdateOneRequiredWithoutLearning_eventsNestedInput
}

export type LearningEventUncheckedUpdateWithoutParticipantsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  recorded_by_id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type LearningEventCreateManyRecorded_byInput = {
  id?: string
  activity: string
  description: string
  skills?: Prisma.LearningEventCreateskillsInput | string[]
  classroom?: string | null
  is_group?: boolean
  logged_at?: Date | string
}

export type LearningEventUpdateWithoutRecorded_byInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  participants?: Prisma.LearningParticipantUpdateManyWithoutLearning_eventNestedInput
}

export type LearningEventUncheckedUpdateWithoutRecorded_byInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  participants?: Prisma.LearningParticipantUncheckedUpdateManyWithoutLearning_eventNestedInput
}

export type LearningEventUncheckedUpdateManyWithoutRecorded_byInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  activity?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  skills?: Prisma.LearningEventUpdateskillsInput | string[]
  classroom?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  is_group?: Prisma.BoolFieldUpdateOperationsInput | boolean
  logged_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type LearningEventCountOutputType
 */

export type LearningEventCountOutputType = {
  participants: number
}

export type LearningEventCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  participants?: boolean | LearningEventCountOutputTypeCountParticipantsArgs
}

/**
 * LearningEventCountOutputType without action
 */
export type LearningEventCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEventCountOutputType
   */
  select?: Prisma.LearningEventCountOutputTypeSelect<ExtArgs> | null
}

/**
 * LearningEventCountOutputType without action
 */
export type LearningEventCountOutputTypeCountParticipantsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.LearningParticipantWhereInput
}


export type LearningEventSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  recorded_by_id?: boolean
  activity?: boolean
  description?: boolean
  skills?: boolean
  classroom?: boolean
  is_group?: boolean
  logged_at?: boolean
  recorded_by?: boolean | Prisma.TeacherDefaultArgs<ExtArgs>
  participants?: boolean | Prisma.LearningEvent$participantsArgs<ExtArgs>
  _count?: boolean | Prisma.LearningEventCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["learningEvent"]>

export type LearningEventSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  recorded_by_id?: boolean
  activity?: boolean
  description?: boolean
  skills?: boolean
  classroom?: boolean
  is_group?: boolean
  logged_at?: boolean
  recorded_by?: boolean | Prisma.TeacherDefaultArgs<ExtArgs>
}, ExtArgs["result"]["learningEvent"]>

export type LearningEventSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  recorded_by_id?: boolean
  activity?: boolean
  description?: boolean
  skills?: boolean
  classroom?: boolean
  is_group?: boolean
  logged_at?: boolean
  recorded_by?: boolean | Prisma.TeacherDefaultArgs<ExtArgs>
}, ExtArgs["result"]["learningEvent"]>

export type LearningEventSelectScalar = {
  id?: boolean
  recorded_by_id?: boolean
  activity?: boolean
  description?: boolean
  skills?: boolean
  classroom?: boolean
  is_group?: boolean
  logged_at?: boolean
}

export type LearningEventOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "recorded_by_id" | "activity" | "description" | "skills" | "classroom" | "is_group" | "logged_at", ExtArgs["result"]["learningEvent"]>
export type LearningEventInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  recorded_by?: boolean | Prisma.TeacherDefaultArgs<ExtArgs>
  participants?: boolean | Prisma.LearningEvent$participantsArgs<ExtArgs>
  _count?: boolean | Prisma.LearningEventCountOutputTypeDefaultArgs<ExtArgs>
}
export type LearningEventIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  recorded_by?: boolean | Prisma.TeacherDefaultArgs<ExtArgs>
}
export type LearningEventIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  recorded_by?: boolean | Prisma.TeacherDefaultArgs<ExtArgs>
}

export type $LearningEventPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "LearningEvent"
  objects: {
    recorded_by: Prisma.$TeacherPayload<ExtArgs>
    participants: Prisma.$LearningParticipantPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    recorded_by_id: string
    activity: string
    description: string
    skills: string[]
    classroom: string | null
    is_group: boolean
    logged_at: Date
  }, ExtArgs["result"]["learningEvent"]>
  composites: {}
}

export type LearningEventGetPayload<S extends boolean | null | undefined | LearningEventDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$LearningEventPayload, S>

export type LearningEventCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<LearningEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: LearningEventCountAggregateInputType | true
  }

export interface LearningEventDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningEvent'], meta: { name: 'LearningEvent' } }
  /**
   * Find zero or one LearningEvent that matches the filter.
   * @param {LearningEventFindUniqueArgs} args - Arguments to find a LearningEvent
   * @example
   * // Get one LearningEvent
   * const learningEvent = await prisma.learningEvent.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends LearningEventFindUniqueArgs>(args: Prisma.SelectSubset<T, LearningEventFindUniqueArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one LearningEvent that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {LearningEventFindUniqueOrThrowArgs} args - Arguments to find a LearningEvent
   * @example
   * // Get one LearningEvent
   * const learningEvent = await prisma.learningEvent.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends LearningEventFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, LearningEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first LearningEvent that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {LearningEventFindFirstArgs} args - Arguments to find a LearningEvent
   * @example
   * // Get one LearningEvent
   * const learningEvent = await prisma.learningEvent.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends LearningEventFindFirstArgs>(args?: Prisma.SelectSubset<T, LearningEventFindFirstArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first LearningEvent that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {LearningEventFindFirstOrThrowArgs} args - Arguments to find a LearningEvent
   * @example
   * // Get one LearningEvent
   * const learningEvent = await prisma.learningEvent.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends LearningEventFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, LearningEventFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more LearningEvents that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {LearningEventFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all LearningEvents
   * const learningEvents = await prisma.learningEvent.findMany()
   * 
   * // Get first 10 LearningEvents
   * const learningEvents = await prisma.learningEvent.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const learningEventWithIdOnly = await prisma.learningEvent.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends LearningEventFindManyArgs>(args?: Prisma.SelectSubset<T, LearningEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a LearningEvent.
   * @param {LearningEventCreateArgs} args - Arguments to create a LearningEvent.
   * @example
   * // Create one LearningEvent
   * const LearningEvent = await prisma.learningEvent.create({
   *   data: {
   *     // ... data to create a LearningEvent
   *   }
   * })
   * 
   */
  create<T extends LearningEventCreateArgs>(args: Prisma.SelectSubset<T, LearningEventCreateArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many LearningEvents.
   * @param {LearningEventCreateManyArgs} args - Arguments to create many LearningEvents.
   * @example
   * // Create many LearningEvents
   * const learningEvent = await prisma.learningEvent.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends LearningEventCreateManyArgs>(args?: Prisma.SelectSubset<T, LearningEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many LearningEvents and returns the data saved in the database.
   * @param {LearningEventCreateManyAndReturnArgs} args - Arguments to create many LearningEvents.
   * @example
   * // Create many LearningEvents
   * const learningEvent = await prisma.learningEvent.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many LearningEvents and only return the `id`
   * const learningEventWithIdOnly = await prisma.learningEvent.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends LearningEventCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, LearningEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a LearningEvent.
   * @param {LearningEventDeleteArgs} args - Arguments to delete one LearningEvent.
   * @example
   * // Delete one LearningEvent
   * const LearningEvent = await prisma.learningEvent.delete({
   *   where: {
   *     // ... filter to delete one LearningEvent
   *   }
   * })
   * 
   */
  delete<T extends LearningEventDeleteArgs>(args: Prisma.SelectSubset<T, LearningEventDeleteArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one LearningEvent.
   * @param {LearningEventUpdateArgs} args - Arguments to update one LearningEvent.
   * @example
   * // Update one LearningEvent
   * const learningEvent = await prisma.learningEvent.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends LearningEventUpdateArgs>(args: Prisma.SelectSubset<T, LearningEventUpdateArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more LearningEvents.
   * @param {LearningEventDeleteManyArgs} args - Arguments to filter LearningEvents to delete.
   * @example
   * // Delete a few LearningEvents
   * const { count } = await prisma.learningEvent.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends LearningEventDeleteManyArgs>(args?: Prisma.SelectSubset<T, LearningEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more LearningEvents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {LearningEventUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many LearningEvents
   * const learningEvent = await prisma.learningEvent.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends LearningEventUpdateManyArgs>(args: Prisma.SelectSubset<T, LearningEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more LearningEvents and returns the data updated in the database.
   * @param {LearningEventUpdateManyAndReturnArgs} args - Arguments to update many LearningEvents.
   * @example
   * // Update many LearningEvents
   * const learningEvent = await prisma.learningEvent.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more LearningEvents and only return the `id`
   * const learningEventWithIdOnly = await prisma.learningEvent.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends LearningEventUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, LearningEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one LearningEvent.
   * @param {LearningEventUpsertArgs} args - Arguments to update or create a LearningEvent.
   * @example
   * // Update or create a LearningEvent
   * const learningEvent = await prisma.learningEvent.upsert({
   *   create: {
   *     // ... data to create a LearningEvent
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the LearningEvent we want to update
   *   }
   * })
   */
  upsert<T extends LearningEventUpsertArgs>(args: Prisma.SelectSubset<T, LearningEventUpsertArgs<ExtArgs>>): Prisma.Prisma__LearningEventClient<runtime.Types.Result.GetResult<Prisma.$LearningEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of LearningEvents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {LearningEventCountArgs} args - Arguments to filter LearningEvents to count.
   * @example
   * // Count the number of LearningEvents
   * const count = await prisma.learningEvent.count({
   *   where: {
   *     // ... the filter for the LearningEvents we want to count
   *   }
   * })
  **/
  count<T extends LearningEventCountArgs>(
    args?: Prisma.Subset<T, LearningEventCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], LearningEventCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a LearningEvent.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {LearningEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends LearningEventAggregateArgs>(args: Prisma.Subset<T, LearningEventAggregateArgs>): Prisma.PrismaPromise<GetLearningEventAggregateType<T>>

  /**
   * Group by LearningEvent.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {LearningEventGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends LearningEventGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: LearningEventGroupByArgs['orderBy'] }
      : { orderBy?: LearningEventGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, LearningEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the LearningEvent model
 */
readonly fields: LearningEventFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for LearningEvent.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__LearningEventClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  recorded_by<T extends Prisma.TeacherDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TeacherDefaultArgs<ExtArgs>>): Prisma.Prisma__TeacherClient<runtime.Types.Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  participants<T extends Prisma.LearningEvent$participantsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.LearningEvent$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$LearningParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the LearningEvent model
 */
export interface LearningEventFieldRefs {
  readonly id: Prisma.FieldRef<"LearningEvent", 'String'>
  readonly recorded_by_id: Prisma.FieldRef<"LearningEvent", 'String'>
  readonly activity: Prisma.FieldRef<"LearningEvent", 'String'>
  readonly description: Prisma.FieldRef<"LearningEvent", 'String'>
  readonly skills: Prisma.FieldRef<"LearningEvent", 'String[]'>
  readonly classroom: Prisma.FieldRef<"LearningEvent", 'String'>
  readonly is_group: Prisma.FieldRef<"LearningEvent", 'Boolean'>
  readonly logged_at: Prisma.FieldRef<"LearningEvent", 'DateTime'>
}
    

// Custom InputTypes
/**
 * LearningEvent findUnique
 */
export type LearningEventFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * Filter, which LearningEvent to fetch.
   */
  where: Prisma.LearningEventWhereUniqueInput
}

/**
 * LearningEvent findUniqueOrThrow
 */
export type LearningEventFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * Filter, which LearningEvent to fetch.
   */
  where: Prisma.LearningEventWhereUniqueInput
}

/**
 * LearningEvent findFirst
 */
export type LearningEventFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * Filter, which LearningEvent to fetch.
   */
  where?: Prisma.LearningEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of LearningEvents to fetch.
   */
  orderBy?: Prisma.LearningEventOrderByWithRelationInput | Prisma.LearningEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for LearningEvents.
   */
  cursor?: Prisma.LearningEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` LearningEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` LearningEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of LearningEvents.
   */
  distinct?: Prisma.LearningEventScalarFieldEnum | Prisma.LearningEventScalarFieldEnum[]
}

/**
 * LearningEvent findFirstOrThrow
 */
export type LearningEventFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * Filter, which LearningEvent to fetch.
   */
  where?: Prisma.LearningEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of LearningEvents to fetch.
   */
  orderBy?: Prisma.LearningEventOrderByWithRelationInput | Prisma.LearningEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for LearningEvents.
   */
  cursor?: Prisma.LearningEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` LearningEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` LearningEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of LearningEvents.
   */
  distinct?: Prisma.LearningEventScalarFieldEnum | Prisma.LearningEventScalarFieldEnum[]
}

/**
 * LearningEvent findMany
 */
export type LearningEventFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * Filter, which LearningEvents to fetch.
   */
  where?: Prisma.LearningEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of LearningEvents to fetch.
   */
  orderBy?: Prisma.LearningEventOrderByWithRelationInput | Prisma.LearningEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing LearningEvents.
   */
  cursor?: Prisma.LearningEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` LearningEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` LearningEvents.
   */
  skip?: number
  distinct?: Prisma.LearningEventScalarFieldEnum | Prisma.LearningEventScalarFieldEnum[]
}

/**
 * LearningEvent create
 */
export type LearningEventCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * The data needed to create a LearningEvent.
   */
  data: Prisma.XOR<Prisma.LearningEventCreateInput, Prisma.LearningEventUncheckedCreateInput>
}

/**
 * LearningEvent createMany
 */
export type LearningEventCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many LearningEvents.
   */
  data: Prisma.LearningEventCreateManyInput | Prisma.LearningEventCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * LearningEvent createManyAndReturn
 */
export type LearningEventCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * The data used to create many LearningEvents.
   */
  data: Prisma.LearningEventCreateManyInput | Prisma.LearningEventCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * LearningEvent update
 */
export type LearningEventUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * The data needed to update a LearningEvent.
   */
  data: Prisma.XOR<Prisma.LearningEventUpdateInput, Prisma.LearningEventUncheckedUpdateInput>
  /**
   * Choose, which LearningEvent to update.
   */
  where: Prisma.LearningEventWhereUniqueInput
}

/**
 * LearningEvent updateMany
 */
export type LearningEventUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update LearningEvents.
   */
  data: Prisma.XOR<Prisma.LearningEventUpdateManyMutationInput, Prisma.LearningEventUncheckedUpdateManyInput>
  /**
   * Filter which LearningEvents to update
   */
  where?: Prisma.LearningEventWhereInput
  /**
   * Limit how many LearningEvents to update.
   */
  limit?: number
}

/**
 * LearningEvent updateManyAndReturn
 */
export type LearningEventUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * The data used to update LearningEvents.
   */
  data: Prisma.XOR<Prisma.LearningEventUpdateManyMutationInput, Prisma.LearningEventUncheckedUpdateManyInput>
  /**
   * Filter which LearningEvents to update
   */
  where?: Prisma.LearningEventWhereInput
  /**
   * Limit how many LearningEvents to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * LearningEvent upsert
 */
export type LearningEventUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * The filter to search for the LearningEvent to update in case it exists.
   */
  where: Prisma.LearningEventWhereUniqueInput
  /**
   * In case the LearningEvent found by the `where` argument doesn't exist, create a new LearningEvent with this data.
   */
  create: Prisma.XOR<Prisma.LearningEventCreateInput, Prisma.LearningEventUncheckedCreateInput>
  /**
   * In case the LearningEvent was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.LearningEventUpdateInput, Prisma.LearningEventUncheckedUpdateInput>
}

/**
 * LearningEvent delete
 */
export type LearningEventDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
  /**
   * Filter which LearningEvent to delete.
   */
  where: Prisma.LearningEventWhereUniqueInput
}

/**
 * LearningEvent deleteMany
 */
export type LearningEventDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which LearningEvents to delete
   */
  where?: Prisma.LearningEventWhereInput
  /**
   * Limit how many LearningEvents to delete.
   */
  limit?: number
}

/**
 * LearningEvent.participants
 */
export type LearningEvent$participantsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningParticipant
   */
  select?: Prisma.LearningParticipantSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningParticipant
   */
  omit?: Prisma.LearningParticipantOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningParticipantInclude<ExtArgs> | null
  where?: Prisma.LearningParticipantWhereInput
  orderBy?: Prisma.LearningParticipantOrderByWithRelationInput | Prisma.LearningParticipantOrderByWithRelationInput[]
  cursor?: Prisma.LearningParticipantWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.LearningParticipantScalarFieldEnum | Prisma.LearningParticipantScalarFieldEnum[]
}

/**
 * LearningEvent without action
 */
export type LearningEventDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the LearningEvent
   */
  select?: Prisma.LearningEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the LearningEvent
   */
  omit?: Prisma.LearningEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LearningEventInclude<ExtArgs> | null
}
